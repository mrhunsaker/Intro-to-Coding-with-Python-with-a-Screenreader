# yaml-language-server: $schema=https://vscodeedu.com/assets/schema/course-v2.schema.json
id: lessonpart7
title: Unit 7
content: >+
  # Unit 7: Classes and Object-Oriented Programming


  ### **Unit 7: Classes and Object-Oriented Programming**


  #### **Lesson 7.1: Why Learn About Classes?**


  * **Proofreading Assignment (No code to proofread in this conceptual
  lesson).**


  #### **Lesson 7.2: Creating and Using a Class**


  * **Proofreading Assignment:**


  - **Scenario:** You're defining a class and creating objects, but syntax
  errors or self issues are popping up.


  - **Code to Proofread:**

    ```
    class Car: 
        def __init__(self, make, model):
            self.make = make
            model = model

        def display_info(self):
            print(f"Make: {self.make}, Model: {self.model}") 

    my_car = Car("Toyota", "Camry")
    my_car.display_info()
    ```

  - **Goal:** Fix the SyntaxError and the logical error in \_\_init\_\_ to
  correctly assign self.model.


  - **Documentation Assignment:**


  * **Scenario:** This code defines a Dog class and creates a dog object.


  * **Code to Document:**

    ```
    class Dog:
        """
        Represents a dog with a name and age.
        """
        def __init__(self, name, age):
            self.name = name
            self.age = age

        def bark(self):
            """
            Makes the dog bark.
            """
            print(f"{self.name} says Woof!")

    my_dog = Dog("Buddy", 3)
    my_dog.bark()
    ```

  * **Task:** Ensure the **docstring** for the Dog class explains its purpose.
  Ensure the **docstring** for bark explains what it does. Add **inline
  comments** explaining attribute assignment in \_\_init\_\_ and the object
  creation/method call.


  * **Goal:** Document a simple class with attributes and methods.


  #### **Lesson 7.3: Working with Attributes and Methods**


  * **Proofreading Assignment:**


  - **Scenario:** You're trying to access or modify attributes and call methods,
  but often forget self. or confuse local variables.


  - **Code to Proofread:**

    ```
    class Robot:
        def __init__(self, name):
            self.name = name
            self.power = 100

        def decrease_power(amount): 
            power -= amount # NameError: power not defined
            print(f"{self.name} power is now {self.power}") 

        def get_name(): 
            return name 

    my_robot = Robot("R2D2")
    print(my_robot.name)
    my_robot.decrease_power(10)
    print(my_robot.get_name())
    ```

  - **Goal:** Fix all methods by adding self as the first parameter and using
  self.attribute when accessing attributes.


  - **Documentation Assignment:**


  * **Scenario:** This code defines a Circle class with methods to calculate
  area and circumference.


  * **Code to Document:**

    ```
    import math

    class Circle:
        """
        Represents a circle and provides methods for calculations.
        """
        def __init__(self, radius):
            self.radius = radius

        def calculate_area(self):
            """
            Calculates the area of the circle.
            """
            return math.pi * self.radius**2

        def calculate_circumference(self):
            """
            Calculates the circumference of the circle.
            """
            return 2 * math.pi * self.radius

    my_circle = Circle(5)
    print(f"Area: {my_circle.calculate_area()}")
    ```

  * **Task:** Ensure **docstrings** for Circle, calculate\_area, and
  calculate\_circumference are clear. Add **inline comments** explaining
  attribute assignment in \_\_init\_\_ and the calculation formulas.


  * **Goal:** Document a class with mathematical methods.


  #### **Lesson 7.4: Inheritance**


  * **Proofreading Assignment:**


  - **Scenario:** You're implementing inheritance, but common mistakes with
  super() or attribute access are causing issues.


  - **Code to Proofread:**

    ```
    class Animal:
        def __init__(self, name):
            self.name = name

        def speak(self):
            return "Unknown sound"

    class Dog(Animal):
        def __init__(self, name, breed):
            super().__init__(name)
            self.breed = breed

        def speak(self):
            return "Woof!"

    class Cat(Animal):
        def __init__(self, name, color):
            self.name = name 
            self.color = color

        def speak(self):
            return "Meow!"

    my_dog = Dog("Buddy", "Golden Retriever")
    print(my_dog.speak())

    my_cat = Cat("Whiskers", "black")
    print(my_cat.speak())
    print(my_cat.name) 
    print(my_dog.breed)
    ```

  - **Goal:** Modify Cat's \_\_init\_\_ to correctly use
  super().\_\_init\_\_(name) for proper inheritance. Explain *why* super() is
  preferred.


  * **Documentation Assignment:**


  - **Scenario:** This code defines a Vehicle class and a Car class that
  inherits from Vehicle.


  - **Code to Document:**

    ```
    class Vehicle:
        """
        A generic class to represent a vehicle.
        """
        def __init__(self, brand):
            self.brand = brand

        def get_brand(self):
            """Returns the brand of the vehicle."""
            return self.brand

    class Car(Vehicle):
        """
        Represents a car, inheriting from Vehicle.
        """
        def __init__(self, brand, model):
            super().__init__(brand) # Initialize parent class
            self.model = model

        def get_model(self):
            """Returns the model of the car."""
            return self.model

    my_car = Car("Toyota", "Camry")
    print(f"Brand: {my_car.get_brand()}, Model: {my_car.get_model()}")
    ```

  - **Task:** Ensure **docstrings** are present for both classes and their
  methods. Add an **inline comment** explaining super().\_\_init\_\_() in the
  Car class.


  - **Goal:** Document a basic inheritance setup.


  #### **Lesson 7.5: Instances as Attributes**


  * **Proofreading Assignment:**


  - **Scenario:** You're using composition, but misremembering how to access
  attributes of the nested object.


  - **Code to Proofread:**

    ```
    class Engine:
        def __init__(self, fuel_type):
            self.fuel_type = fuel_type

        def start(self):
            return f"Engine running on {self.fuel_type}."

    class Car:
        def __init__(self, make, model, engine_type):
            self.make = make
            self.model = model
            self.engine = Engine(engine_type) 

        def get_engine_fuel(): 
            return self.engine.fuel_type 

        def car_start_sound(self):
            return self.engine.start 

    my_car = Car("Honda", "Civic", "Gasoline")
    print(f"Car engine fuel: {my_car.get_engine_fuel()}")
    print(f"Car starts: {my_car.car_start_sound()}")
    ```

  - **Goal:** Fix the TypeError by adding self to get\_engine\_fuel. Fix the
  AttributeError by adding () to self.engine.start.


  - **Documentation Assignment:**


  * **Scenario:** This code models a Book that *has a* Author.


  * **Code to Document:**

    ```
    class Author:
        """
        Represents an author with a name.
        """
        def __init__(self, name):
            self.name = name

        def get_name(self):
            """Returns the author's name."""
            return self.name

    class Book:
        """
        Represents a book with a title and an Author instance.
        """
        def __init__(self, title, author_name):
            self.title = title
            self.author = Author(author_name) # Composition: Book 'has a' Author

        def get_book_info(self):
            """Returns information about the book and its author."""
            return f"'{self.title}' by {self.author.get_name()}"

    author1 = Author("Jane Austen")
    book1 = Book("Pride and Prejudice", author1.name)
    print(book1.get_book_info())
    ```

  * **Task:** Ensure **docstrings** for both classes and their methods are
  clear. Add an **inline comment** explaining the composition in
  Book.\_\_init\_\_ and how self.author.get\_name() accesses the nested object's
  method.


  * **Goal:** Document a class demonstrating composition.

showEditor: true
editors:
  - course1/proofreading.py
