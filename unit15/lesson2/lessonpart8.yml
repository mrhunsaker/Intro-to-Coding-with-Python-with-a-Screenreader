# yaml-language-server: $schema=https://vscodeedu.com/assets/schema/course-v2.schema.json
id: lessonpart8
title: Unit 8
content: >+
  ### **Unit 8: Files and Exceptions**


  #### **Lesson 8.1: Reading from a File**


  * **Proofreading Assignment:**


  - **Scenario:** You're trying to read from a file, but common errors like
  FileNotFoundError or incorrect method usage are occurring.

  - **Code to Proofread:**\
    \# Assuming 'non\_existent\_file.txt' does not exist\
    with open("non\_existent\_file.txt", "r") as file: # FileNotFoundError if not handled\
        content = file.read()\
        print(content)\
    \
    \# Assuming 'my\_data.txt' exists with "Line 1\nLine 2\n"\
    with open("my\_data.txt", "r") as f:\
        lines = f.readline() # This only reads one line\
        print(lines)\
    \
        all\_lines = f.readall() # AttributeError: 'io.TextIOWrapper' object has no attribute 'readall'\
        print(all\_lines)\
    \
    \# To prepare for proofreading, create a file named 'my\_data.txt' with some content\
    \# Example content for my\_data.txt:\
    \# Line 1\
    \# Line 2\
    \# Line 3\

  - **Errors to Find:**


  1. FileNotFoundError: For non\_existent\_file.txt.

  2. Logical Error: f.readline() only reads one line. The intention was likely
  to read all.

  3. AttributeError: f.readall() is not a valid method (should be f.read() or
  f.readlines()).


  * **Goal:** Handle the FileNotFoundError with a try-except block. Correct the
  logical error to read all lines. Fix the AttributeError.


  - **Documentation Assignment:**


  * **Scenario:** This code reads the entire content of a file named sample.txt.

  * **Code to Document:**\
    \# Ensure 'sample.txt' exists in the same directory as this script\
    \# with some text content.\
    with open("sample.txt", "r") as file:\
        content = file.read()\
        print(content)\

  * **Task:** Add a **docstring** for the script. Add **inline comments**
  explaining with open(), the "r" mode, and .read().

  * **Goal:** Document reading an entire file.


  #### **Lesson 8.2: Writing to a File**


  * **Proofreading Assignment:**


  - **Scenario:** You're writing to files, but using the wrong modes or
  forgetting newlines.

  - **Code to Proofread:**\
    \# Writing a new file\
    with open("output.txt", "r") as file: # Wrong mode for writing\
        file.write("Hello, world!")\
    \
    \# Appending to a file\
    with open("log.txt", "w") as log\_file: # Wrong mode, will overwrite\
        log\_file.write("First log entry.")\
        log\_file.write("Second log entry.") # Missing newline\
    \
    \# This part should be correct if the first parts are fixed\
    \# Ensure 'new\_output.txt' is ready\
    with open("new\_output.txt", "a") as f:\
        f.write("Appended line.\n")\

  - **Errors to Find:**


  1. UnsupportedOperation: open("output.txt", "r") cannot be used for writing.

  2. Logical Error: open("log.txt", "w") will overwrite. It should be "a" for
  appending if multiple calls are intended to add.

  3. Logical Error: log\_file.write("Second log entry.") is missing a newline,
  so it will append on the same line.


  * **Goal:** Fix the UnsupportedOperation by changing the file mode. Change the
  log.txt open mode to append. Add a newline character to the second log entry.


  - **Documentation Assignment:**


  * **Scenario:** This code writes two lines to a new file called my\_notes.txt.

  * **Code to Document:**\
    with open("my\_notes.txt", "w") as file:\
        file.write("This is the first line.\n")\
        file.write("This is the second line.\n")\
    print("Notes written to my\_notes.txt")\

  * **Task:** Add a **docstring** for the script. Add **inline comments**
  explaining the "w" mode and the use of \n.

  * **Goal:** Document writing to a file.


  #### **Lesson 8.3: Exceptions: Handling Errors**


  * **Proofreading Assignment:**


  - **Scenario:** You're trying to handle exceptions, but either not catching
  the right one, or the try-except block is placed incorrectly.

  - **Code to Proofread:**\
    \# Division by zero\
    try:\
        result = 10 / 0\
    except ValueError: # Wrong exception type\
        print("Caught a value error!")\
    print("Program continues after division.")\
    \
    \# File not found\
    try:\
        with open("non\_existent.txt", "r") as f:\
            content = f.read()\
            print(content)\
    except ZeroDivisionError: # Wrong exception type\
        print("Caught a division by zero error!")\
    \
    \# Invalid input for int()\
    user\_input\_num = input("Enter a number: ")\
    result = int(user\_input\_num) # Error will occur outside try-except if not numeric\
    try:\
        print(f"Your number is: {result}")\
    except ValueError:\
        print("Invalid input for number.")\

  - **Errors to Find:**


  1. Logical Error: First try-except block catches ValueError for a
  ZeroDivisionError.

  2. Logical Error: Second try-except block catches ZeroDivisionError for a
  FileNotFoundError.

  3. Logical Error: Third try-except block places the int() conversion *outside*
  the try, so ValueError won't be caught correctly.


  * **Goal:** Correctly identify and handle ZeroDivisionError and
  FileNotFoundError. Move the int() conversion into the try block for the third
  scenario.


  - **Documentation Assignment:**


  * **Scenario:** This code attempts a division and handles a potential
  ZeroDivisionError.

  * **Code to Document:**\
    try:\
        numerator = 10\
        denominator = int(input("Enter a denominator: "))\
        result = numerator / denominator\
        print(f"Result: {result}")\
    except ZeroDivisionError:\
        print("Error: Cannot divide by zero!")\
    except ValueError:\
        print("Error: Invalid input. Please enter a valid number.")\

  * **Task:** Add a **docstring** for the script. Add **inline comments**
  explaining the try block, each except block, and the specific errors they
  catch.

  * **Goal:** Document robust error handling for division.


  #### **Lesson 8.4: The else Block and finally Block**


  * **Proofreading Assignment:**


  - **Scenario:** You're using else and finally with try-except, but they're not
  always placed or behaving as expected.

  - **Code to Proofread:**\
    \# Scenario 1: else block\
    def safe\_divide(a, b):\
        try:\
            result = a / b\
        except ZeroDivisionError:\
            print("Division by zero error!")\
        else: # This else should be for the try, not just print\
            print(f"Division successful: {result}")\
        finally: # This finally should be for the try, not just print\
            print("Safe divide function finished.")\
    \
    safe\_divide(10, 2)\
    safe\_divide(10, 0)\
    \
    \# Scenario 2: finally block\
    file\_name = "data.txt" # Assume this file exists\
    try:\
        f = open(file\_name, "r")\
        content = f.read()\
        print(content)\
    except FileNotFoundError:\
        print(f"File {file\_name} not found.")\
    finally:\
        f.close() # This will cause NameError if FileNotFoundError occurs and f isn't defined\

  - **Errors to Find:**


  1. Logical Error: In safe\_divide, the else and finally are not properly
  aligned with the try block in Python syntax. They are part of the try-except
  construct.

  2. NameError: In the file handling scenario, if FileNotFoundError occurs, f is
  never assigned, so f.close() in finally will raise a NameError.


  * **Goal:** Correct the indentation and placement of else and finally in
  safe\_divide. Modify the file handling finally block to only close f if it was
  successfully opened (e.g., by initializing f = None before the try).


  - **Documentation Assignment:**


  * **Scenario:** This code attempts to open and read a file, always printing a
  completion message.

  * **Code to Document:**\
    file\_path = "existing\_file.txt" # Assume this file exists\
    try:\
        with open(file\_path, "r") as f:\
            content = f.read()\
            print(f"File content: {content}")\
    except FileNotFoundError:\
        print(f"Error: {file\_path} not found.")\
    else:\
        print("File reading was successful.")\
    finally:\
        print("File operation attempted.")\

  * **Task:** Add a **docstring** for the script. Add **inline comments** for
  the try, except, else, and finally blocks, explaining when each block
  executes.

  * **Goal:** Document the full try-except-else-finally structure.


  #### **Lesson 8.5: Storing Data with JSON**


  * **Proofreading Assignment:**


  - **Scenario:** You're trying to save and load data using JSON, but common
  mistakes with the json module or file handling are occurring.

  - **Code to Proofread:**\
    import json\
    \
    data\_to\_save = {"name": "Test User", "id": 123}\
    \
    \# Saving data\
    with open("user\_data.json", "w") as f:\
        f.write(json.dumps(data\_to\_save)) # Missing newline, also dump() is better\
    \
    \# Loading data\
    try:\
        with open("user\_data.json", "r") as f:\
            loaded\_data = json.load(f)\
            print(f"Loaded data: {loaded\_data}")\
    except json.JSONDecodeError:\
        print("Error: JSON file is corrupted.")\
    except FileNotFoundError:\
        print("Error: JSON file not found.")\
    \
    \# Incorrect JSON structure in file\
    \# Assume a file named 'bad\_data.json' exists with content:\
    \# {"item": 10, "value": 20, "extra\_comma": } # Malformed JSON\
    try:\
        with open("bad\_data.json", "r") as f:\
            corrupted\_data = json.load(f)\
            print(f"Corrupted data: {corrupted\_data}")\
    except FileNotFoundError:\
        print("Bad data file not found.")\
    except ValueError: # Wrong exception type for JSON corruption\
        print("Caught a ValueError!")\

  - **Errors to Find:**


  1. Logical/Best Practice: When writing JSON, it's better to use
  json.dump(data, file\_object) directly, rather than json.dumps() and then
  f.write(). Also, f.write(json.dumps(data\_to\_save)) won't add a newline, so
  if you append later, it'll be on the same line.

  2. Logical Error: The except block for bad\_data.json catches ValueError when
  it should catch json.JSONDecodeError.


  * **Goal:** Change f.write(json.dumps(...)) to json.dump(data\_to\_save, f).
  Change the exception type for bad\_data.json to json.JSONDecodeError.


  - **Documentation Assignment:**


  * **Scenario:** This code saves a list of dictionaries (representing contacts)
  to a JSON file and then loads it back.

  * **Code to Document:**\
    import json\
    \
    contacts = \[\
        {"name": "Alice", "phone": "111-222-3333"},\
        {"name": "Bob", "phone": "444-555-6666"}\
    ]\
    \
    \# Save contacts to JSON file\
    with open("contacts.json", "w") as f:\
        json.dump(contacts, f, indent=4) # indent makes it human-readable\
    \
    \# Load contacts from JSON file\
    with open("contacts.json", "r") as f:\
        loaded\_contacts = json.load(f)\
    \
    print("Loaded Contacts:")\
    for contact in loaded\_contacts:\
        print(f"- Name: {contact\['name']}, Phone: {contact\['phone']}")\

  * **Task:** Add a **docstring** for the script. Add **inline comments**
  explaining json.dump() with the indent argument, and json.load().

  * **Goal:** Document saving and loading structured data with JSON.Enter your
  content here

