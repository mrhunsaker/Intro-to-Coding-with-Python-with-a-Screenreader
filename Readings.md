Here is a comprehensive breakdown of the page numbers from the Zelle and Matthes texts for each lesson and unit in the curriculum:

Unit 0: Setting Up Your Accessible Python Development Environment
This unit focuses on setting up the development environment, including VS Code and screen reader configurations. This content primarily draws from the supplementary materials provided for the curriculum, and while underlying concepts are in the core texts, the specific setup instructions are detailed in the curriculum's own materials.
• Lesson 0.1: Installing Python and Visual Studio Code
    ◦ Matthes: Chapter 1, pages 3-14
(for setting up and running your first program, including Python installation steps); Appendix A, pages 463-468 (for installation and troubleshooting, including VS Code setup
).
• Lesson 0.2: Configuring Your Screen Reader for VS Code
    ◦ Matthes: Appendix B, pages 469-476
(for detailed information on text editors and IDEs, including VS Code); Appendix C, pages 477-482
(for general guidance on getting help and finding documentation, which would include screen reader specific settings).
• Lesson 0.3: Setting Up Your VS Code Workspace
    ◦ Matthes: Appendix B, pages 469-476
(for VS Code setup and configuration); Chapter 8, pages 149-152
(for storing functions in modules, which emphasizes code organization within a workspace).
• Lesson 0.4: Python Environments and Terminal Usage
    ◦ Matthes: Chapter 1, pages 3-14
(for running Python in a terminal); Chapter 8, pages 149-152 (for importing modules and functions, related to package management); Chapter 11, pages 210-211
(for installing external libraries like pytest using pip).
Unit 1: Foundations of Computing and Getting Started with Python

• Lesson 1.1: Welcome to Computer Science
    ◦ Zelle: Chapter 1, pages 1-7
(covering "The Universal Machine", "Program Power", "What is Computer Science?", "Hardware Basics", and "Programming Languages").
    ◦ Matthes: Chapter 1, pages 3-14
(general introduction to Python and programming).
• Lesson 1.2: Your First Python Program: "Hello World!"
    ◦ Zelle: Chapter 1, pages 7-13
(covering "The Magic of Python" and "Inside a Python Program").
    ◦ Matthes: Chapter 1, pages 3-14
(for writing, saving, and running a basic print() statement
).
• Lesson 1.3: Variables and Simple Data Types
    ◦ Zelle: Chapter 2, pages 24-26
(introducing "Names" and "Expressions").
    ◦ Matthes: Chapter 2, pages 15-32
(covering "Variables and Simple Data Types", "Naming and Using Variables", "Strings", and "Numbers").
Unit 2: Writing Simple Programs and Numeric Computations
• Lesson 2.1: The Software Development Process
    ◦ Zelle: Chapter 2, pages 21-22
(describing "Create a Design", "Implement the Design", "Test/Debug the Program") and pages 35-36
(listing the steps in the "Chapter Summary").
• Lesson 2.2: Elements of Programs: Expressions and Assignment
    ◦ Zelle: Chapter 2, pages 24-26
(on "Names" and "Expressions").
• Lesson 2.3: Input and Output Revisited
    ◦ Zelle: Chapter 2, pages 27-33
(detailing "Output Statements" and "Input Statement").
    ◦ Matthes: Chapter 7, pages 114-116
(explaining the input() function).
• Lesson 2.4: Computing with Numbers and Type Conversions
    ◦ Zelle: Chapter 3, pages 41-48
(focusing on "Numeric Data Types").
    ◦ Matthes: Chapter 2, pages 26-28
(covering "Numbers", "Integers", "Floats", and "Integers and Floats").
• Lesson 2.5: Using the Math Library
    ◦ Zelle: Chapter 3, pages 49-51
(introducing "The Python math library" and "Some math library functions").
Unit 3: Control Flow: Decisions and Loops
• Lesson 3.1: Boolean Expressions and if Statements
    ◦ Zelle: Chapter 7, pages 165-173
(introducing "Decision Structures", if statements, and "Conditions"); Chapter 8, pages 204-205
(on "Boolean Operators").
    ◦ Matthes: Chapter 5, pages 71-78
(covering if statements and "Conditional Tests").
• Lesson 3.2: Chained Conditionals (elif, else)
    ◦ Zelle: Chapter 7, pages 173-176
(on "The if-else statement" and "Multi-Way Decisions").
    ◦ Matthes: Chapter 5, pages 79-84
(covering if-else chains and if-elif-else chains).
• Lesson 3.3: Introduction to Lists
    ◦ Zelle: Chapter 5, pages 105-106
(on "Lists as Sequences").
    ◦ Matthes: Chapter 3, pages 33-47
(introducing "Introducing Lists", "What Is a List?", and "Accessing Elements in a List").
• Lesson 3.4: Iterating with for Loops
    ◦ Zelle: Chapter 2, pages 34-36
(on "Definite Loops", the for statement, and "Counted Loop").
    ◦ Matthes: Chapter 4, pages 49-60
(covering "Working with Lists" and "Looping Through an Entire List").
• Lesson 3.5: Basic String Operations
    ◦ Zelle: Chapter 5, pages 99-102
(on "The String Data Type" and "Simple String Processing", including len()); pages 111-115
(on "String Methods").
    ◦ Matthes: Chapter 2, pages 19-25
(on "Strings", string methods like lower() and upper(), and string formatting).
Unit 4: Data Structures: Lists and Dictionaries
• Lesson 4.1: More on Lists
    ◦ Matthes: Chapter 3, pages 36-39
(on "Modifying Elements in a List", "Adding Elements to a List" (e.g., append(), insert()), and "Removing Elements from a List" (del, pop(), remove())).
• Lesson 4.2: Organizing Lists
    ◦ Matthes: Chapter 3, pages 39-45
(on "Organizing a List" (sort(), sorted()) and "Printing a List in Reverse Order" (reverse(), len())).
• Lesson 4.3: Tuples: Immutable Lists
    ◦ Matthes: Chapter 4, pages 65-67
(specifically "Tuples").
• Lesson 4.4: Introducing Dictionaries
    ◦ Zelle: Chapter 11, pages 307-309
(on "Non-Sequential Collections", "Dictionary Basics", and "Dictionary Operations").
    ◦ Matthes: Chapter 6, pages 91-98
(covering "Dictionaries", accessing, adding, modifying, and removing key-value pairs).
• Lesson 4.5: Looping Through Dictionaries
    ◦ Zelle: Chapter 11, pages 309-310
(covering keys(), values(), and items() methods).
    ◦ Matthes: Chapter 6, pages 99-104
(on "Looping Through a Dictionary", its keys, values, and key-value pairs).
Unit 5: User Input and while Loops
• Lesson 5.1: How the input() Function Works
    ◦ Zelle: Chapter 2, pages 30-33
(on the input() statement).
    ◦ Matthes: Chapter 7, pages 114-116
(on the input() function and numerical input).
• Lesson 5.2: The while Loop in Action
    ◦ Zelle: Chapter 8, pages 195-197
(introducing the while statement and infinite loops).
    ◦ Matthes: Chapter 7, pages 116-118
(on basic while loops).
• Lesson 5.3: Using Flags and break to Exit Loops
    ◦ Zelle: Chapter 8, pages 209-211
(on "The Loop and a Half" and break statements).
    ◦ Matthes: Chapter 7, pages 118-121
(on using a flag and break to exit a loop).
• Lesson 5.4: Using continue in Loops
    ◦ Matthes: Chapter 7, page 122
(on the continue statement).
• Lesson 5.5: Avoiding Infinite Loops
    ◦ Zelle: Chapter 8, pages 196-197
(specifically "Infinite Loop").
    ◦ Matthes: Chapter 7, page 123
(on "Avoiding Infinite Loops").
Unit 6: Functions
• Lesson 6.1: Defining Functions
    ◦ Zelle: Chapter 6, pages 137-142
(on "The Function of Functions" and "Functions, Informally").
    ◦ Matthes: Chapter 8, pages 129-130
(on "Defining a Function").
• Lesson 6.2: Passing Arguments
    ◦ Zelle: Chapter 6, pages 144-147
(on "Functions and Parameters: The Exciting Details").
    ◦ Matthes: Chapter 8, pages 131-137
(on "Passing Information to a Function", "Positional Arguments", and "Keyword Arguments").
• Lesson 6.3: Return Values
    ◦ Zelle: Chapter 6, pages 147-151
(on "Getting Results from a Function" and "Functions That Return Values").
    ◦ Matthes: Chapter 8, pages 137-142
(on "Return Values" and "Returning a Simple Value").
• Lesson 6.4: Functions with Lists and Dictionaries
    ◦ Zelle: Chapter 6, pages 151-154
(on "Functions that Modify Parameters").
    ◦ Matthes: Chapter 8, pages 142-146
(on "Passing a List" and "Modifying a List in a Function").
• Lesson 6.5: Arbitrary Number of Arguments
    ◦ Matthes: Chapter 8, pages 146-149
(on "Passing an Arbitrary Number of Arguments" and "Using Arbitrary Keyword Arguments").
Unit 7: Classes and Object-Oriented Programming
• Lesson 7.1: Why Learn About Classes?
    ◦ Zelle: Chapter 4, pages 65-67
(for "The Object of Objects"); Chapter 10, pages 247-248
(for "Quick Review of Objects").
    ◦ Matthes: Chapter 9, page 157
(introducing "Classes").
• Lesson 7.2: Creating and Using a Class
    ◦ Zelle: Chapter 10, pages 248-254
(for example class definitions like MSDie).
    ◦ Matthes: Chapter 9, pages 158-162
(on "Creating a Dog Class", the __init__() method, and creating instances).
• Lesson 7.3: Working with Attributes and Methods
    ◦ Zelle: Chapter 10, pages 254-256
(on MSDie class and calling methods).
    ◦ Matthes: Chapter 9, pages 162-166
(on "Working with Attributes and Methods", accessing and modifying attributes).
• Lesson 7.4: Inheritance
    ◦ Zelle: Chapter 12, pages 351-352
(specifically "Inheritance").
    ◦ Matthes: Chapter 9, pages 167-170
(on "Inheritance", __init__() for child classes, and overriding methods).
• Lesson 7.5: Instances as Attributes
    ◦ Zelle: Chapter 10, pages 262-263
(on "Encapsulating Useful Abstractions"); Chapter 11, pages 296-299
(on "Designing with Lists and Classes" for composition example).
    ◦ Matthes: Chapter 9, pages 170-172
(specifically "Instances as Attributes").
Unit 8: Files and Exceptions
• Lesson 8.1: Reading from a File
    ◦ Zelle: Chapter 5, pages 125-127
(on "File Processing" and "Simple File Processing").
    ◦ Matthes: Chapter 10, pages 184-189
(on "Reading from a File" and working with file contents).
• Lesson 8.2: Writing to a File
    ◦ Zelle: Chapter 5, pages 127-128
(on "Writing to a File").
    ◦ Matthes: Chapter 10, pages 190-192
(on writing to files and appending).
• Lesson 8.3: Exceptions: Handling Errors
    ◦ Zelle: Chapter 7, pages 177-179
(on "Handling Exceptional Cases").
    ◦ Matthes: Chapter 10, pages 192-199
(on "Exceptions" and try-except blocks).
• Lesson 8.4: The else Block and finally Block
    ◦ Matthes: Chapter 10, pages 194-195
(on the else and finally blocks).
• Lesson 8.5: Storing Data with JSON
    ◦ Matthes: Chapter 10, pages 200-204
(on "Storing Data" and using the json module for json.dumps() and json.loads()).
Unit 9: Testing Your Code and Introduction to Data Analysis
• Lesson 9.1: Testing a Function
    ◦ Zelle: Chapter 9, pages 236-237
(specifically "Unit Testing").
    ◦ Matthes: Chapter 11, pages 209-217
(on "Testing Your Code" and "Testing a Function" with unittest).
• Lesson 9.2: Testing a Class
    ◦ Matthes: Chapter 11, pages 217-220
(on "Testing a Class" and the setUp() method).
• Lesson 9.3: Introduction to Random Numbers
    ◦ Zelle: Chapter 9, pages 223-225
(on "Pseudo Random Numbers").
    ◦ Matthes: Chapter 15, pages 312-314, 320-322
(on generating random data, e.g., random walks and dice rolls, focusing on the random module rather than visualization).
• Lesson 9.4: Analyzing Text Data
    ◦ Zelle: Chapter 11, pages 310-315
(on "Example Program: Word Frequency").
    ◦ Matthes: Chapter 10, pages 196-199
(on "Analyzing Text" and counting words); Chapter 15, page 322
(general data generation concepts for text).
• Lesson 9.5: Working with CSV Data (text-based)
    ◦ Matthes: Chapter 16, pages 329-341
(on "Downloading Data" and "The CSV File Format", with emphasis on text processing for a visually impaired student).
Unit 10: Project-Based Learning: Building Text-Based Applications
This unit focuses on integrating learned concepts into larger, text-based applications. While specific projects may differ from those in the textbooks (e.g., text-based adventure games instead of graphical games), the underlying principles of design and modularity are covered.
• Lesson 10.1: Designing Your Project
    ◦ Zelle: Chapter 9, pages 225-235
(on "Top-Down Design" and "Summary of the Design Process").
    ◦ Matthes: Part II: Projects, pages 225-226
(overview of project-based learning).
• Lesson 10.2: Building a Text-Based Adventure Game (Part 1)
    ◦ Matthes: Chapter 6, pages 105-111
(on "Nesting" lists and dictionaries for representing complex game structures).
• Lesson 10.3: Building a Text-Based Adventure Game (Part 2)
    ◦ Matthes: Chapter 6, pages 105-111
(for advanced data structuring with nested lists/dictionaries); Chapter 7, pages 118-123
(for user input, loops, and flags for game state management).
• Lesson 10.4: Developing a Command-Line Tool
    ◦ Zelle: Chapter 11, pages 301-306
(on "Case Study: Python Calculator" as an example of designing an application as an object).
    ◦ Matthes: Chapter 7, pages 113-128
(for interactive programs with loops and user input); Chapter 8, pages 129-154 (for defining and using functions for modularity); Chapter 10, pages 183-206
(for file I/O and exception handling for persistence).
• Lesson 10.5: Refinement and User Experience
    ◦ Zelle: Chapter 2, pages 27-28
(on "Output Statements"); Chapter 7, pages 177-179
(on "Handling Exceptional Cases" for robust input).
    ◦ Matthes: Chapter 7, pages 114-115
(on writing clear prompts); Chapter 10, pages 192-199
(for graceful error handling).
Unit 11: Capstone Project - Accessible Personal Data Manager
This unit involves building a GUI application using NiceGUI. NiceGUI is an external library and is not covered in the provided Zelle or Matthes textbooks. The lessons in this unit apply Python programming concepts learned in previous units within the context of this new framework. The focus is on making the data accessible and interpretable for screen reader users, drawing on the principles outlined in the curriculum's supplementary materials for data visualization accessibility
.
• Lesson 11.1: Introduction to NiceGUI and Project Overview
    ◦ This lesson introduces GUI concepts and the NiceGUI framework. This material is not from the Zelle or Matthes textbooks. It relies on a provided skeleton application (app_skeleton.py) for the student to work with
.
• Lesson 11.2: Designing the Data Model and Implementing "Add Item"
    ◦ Applies concepts from Unit 7 (Classes)
and Unit 6 (Functions)
.
• Lesson 11.3: Data Persistence: Saving and Loading Data
    ◦ Applies concepts from Unit 8 (Files and Exceptions), Lesson 8.5 (Storing Data with JSON)
.
• Lesson 11.4: Displaying and Managing Items
    ◦ Applies concepts from Unit 4 (Lists and Dictionaries)
and Unit 6 (Functions)
for data manipulation and display logic.
• Lesson 11.5: Implementing "Edit" and "Delete" Functionality
    ◦ Applies concepts from Unit 4 (Lists and Dictionaries)
for data modification and removal, and Unit 6 (Functions) for structuring the logic.